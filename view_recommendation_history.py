#!/usr/bin/env python3
"""
Recommendation History Analytics Viewer
======================================

Comprehensive tool for viewing, analyzing, and managing historical trading recommendations
generated by the cron job system. Provides insights into recommendation patterns, performance,
and trends for better decision making.

Usage Examples:
    python view_recommendation_history.py history --days 7
    python view_recommendation_history.py analytics --strategy shortterm
    python view_recommendation_history.py symbols --symbol RELIANCE --days 30
    python view_recommendation_history.py performance --top 20
    python view_recommendation_history.py export --format csv --days 7
    python view_recommendation_history.py compare --strategies shortterm,swing
    python view_recommendation_history.py live --refresh 30
"""

import asyncio
import argparse
import json
import csv
import sys
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
from tabulate import tabulate
import pandas as pd

# Add the api directory to the Python path
sys.path.append('api')

from models.recommendation_history_models import (
    recommendation_history_storage, 
    RecommendationStrategy,
    RecommendationAction
)

class RecommendationHistoryViewer:
    """Analytics viewer for historical trading recommendations."""
    
    def __init__(self):
        self.storage = recommendation_history_storage
    
    async def initialize(self):
        """Initialize the storage connection."""
        await self.storage.initialize()
    
    async def close(self):
        """Close the storage connection."""
        await self.storage.close()
    
    async def show_recommendation_history(self, 
                                          symbol: Optional[str] = None,
                                          strategy: Optional[str] = None,
                                          days: int = 7,
                                          limit: int = 50):
        """Show filtered recommendation history."""
        
        try:
            print(f"\nüîç Recommendation History")
            print("=" * 60)
            
            # Convert strategy string to enum
            strategy_enum = None
            if strategy:
                strategy_mapping = {
                    'shortterm': RecommendationStrategy.SHORTTERM,
                    'swing': RecommendationStrategy.SWING,
                    'longterm': RecommendationStrategy.LONGTERM,
                    'intraday': RecommendationStrategy.INTRADAY
                }
                strategy_enum = strategy_mapping.get(strategy.lower())
            
            # Calculate date range
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            # Get history
            history = await self.storage.get_recommendation_history(
                symbol=symbol,
                strategy=strategy_enum,
                start_date=start_date,
                end_date=end_date,
                limit=limit
            )
            
            if not history:
                print("‚ùå No recommendations found for the specified criteria")
                return
            
            # Format for display
            table_data = []
            for rec in history:
                table_data.append([
                    rec.get('symbol', 'N/A'),
                    rec.get('name', 'N/A')[:25],
                    rec.get('strategy', 'N/A'),
                    f"‚Çπ{rec.get('price_at_recommendation', 0):.2f}",
                    f"{rec.get('overall_score', 0):.1f}",
                    rec.get('recommendation_action', 'N/A'),
                    rec.get('generated_at', 'N/A')[:19] if rec.get('generated_at') else 'N/A',
                    rec.get('market_condition', 'N/A')
                ])
            
            headers = [
                'Symbol', 'Company', 'Strategy', 'Price', 'Score', 
                'Action', 'Generated At', 'Market'
            ]
            
            print(f"üìä Found {len(history)} recommendations")
            print(f"üìÖ Date Range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
            if symbol:
                print(f"üéØ Symbol: {symbol}")
            if strategy:
                print(f"üìà Strategy: {strategy}")
            print()
            
            print(tabulate(table_data, headers=headers, tablefmt='grid'))
            
        except Exception as e:
            print(f"‚ùå Error showing recommendation history: {e}")
    
    async def show_batch_analytics(self, 
                                   strategy: Optional[str] = None,
                                   days: int = 30):
        """Show analytics on recommendation batches."""
        
        try:
            print(f"\nüìä Recommendation Batch Analytics")
            print("=" * 60)
            
            # Convert strategy string to enum
            strategy_enum = None
            if strategy:
                strategy_mapping = {
                    'shortterm': RecommendationStrategy.SHORTTERM,
                    'swing': RecommendationStrategy.SWING,
                    'longterm': RecommendationStrategy.LONGTERM,
                    'intraday': RecommendationStrategy.INTRADAY
                }
                strategy_enum = strategy_mapping.get(strategy.lower())
            
            analytics = await self.storage.get_batch_analytics(
                strategy=strategy_enum,
                days=days
            )
            
            if 'error' in analytics:
                print(f"‚ùå Error getting analytics: {analytics['error']}")
                return
            
            print(f"üìÖ Analysis Period: Last {analytics.get('analysis_period_days', days)} days")
            print()
            
            # Summary statistics
            summary = analytics.get('summary', {})
            if summary:
                print("üìà Summary Statistics:")
                print(f"  ‚Ä¢ Total Strategies: {summary.get('total_strategies', 0)}")
                print(f"  ‚Ä¢ Total Batches: {summary.get('total_batches', 0)}")
                print(f"  ‚Ä¢ Total Recommendations: {summary.get('total_recommendations', 0)}")
                print()
            
            # Strategy-specific analytics
            strategy_analytics = analytics.get('strategy_analytics', {})
            if strategy_analytics:
                print("üéØ Strategy Breakdown:")
                table_data = []
                for strat_name, data in strategy_analytics.items():
                    table_data.append([
                        strat_name.upper(),
                        data.get('total_batches', 0),
                        data.get('total_recommendations', 0),
                        f"{data.get('avg_recommendations_per_batch', 0):.1f}",
                        f"{data.get('avg_score', 0):.1f}",
                        data.get('unique_symbols_count', 0)
                    ])
                
                headers = [
                    'Strategy', 'Batches', 'Total Recs', 'Avg/Batch', 'Avg Score', 'Unique Symbols'
                ]
                
                print(tabulate(table_data, headers=headers, tablefmt='grid'))
            
        except Exception as e:
            print(f"‚ùå Error showing batch analytics: {e}")
    
    async def show_symbol_analysis(self, 
                                   symbol: str,
                                   days: int = 30):
        """Show detailed analysis for a specific symbol."""
        
        try:
            print(f"\nüéØ Symbol Analysis: {symbol.upper()}")
            print("=" * 60)
            
            # Get history for symbol
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            history = await self.storage.get_recommendation_history(
                symbol=symbol.upper(),
                start_date=start_date,
                end_date=end_date,
                limit=100
            )
            
            if not history:
                print(f"‚ùå No recommendations found for {symbol.upper()}")
                return
            
            print(f"üìä Found {len(history)} recommendations for {symbol.upper()}")
            print(f"üìÖ Date Range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
            print()
            
            # Strategy breakdown
            strategy_counts = {}
            action_counts = {}
            scores = []
            prices = []
            
            for rec in history:
                strategy = rec.get('strategy', 'unknown')
                action = rec.get('recommendation_action', 'unknown')
                score = rec.get('overall_score', 0)
                price = rec.get('price_at_recommendation', 0)
                
                strategy_counts[strategy] = strategy_counts.get(strategy, 0) + 1
                action_counts[action] = action_counts.get(action, 0) + 1
                
                if score > 0:
                    scores.append(score)
                if price > 0:
                    prices.append(price)
            
            # Display strategy breakdown
            print("üìà Strategy Breakdown:")
            for strategy, count in strategy_counts.items():
                percentage = (count / len(history)) * 100
                print(f"  ‚Ä¢ {strategy.upper()}: {count} ({percentage:.1f}%)")
            print()
            
            # Display action breakdown
            print("üéØ Action Breakdown:")
            for action, count in action_counts.items():
                percentage = (count / len(history)) * 100
                print(f"  ‚Ä¢ {action.upper()}: {count} ({percentage:.1f}%)")
            print()
            
            # Statistics
            if scores:
                avg_score = sum(scores) / len(scores)
                min_score = min(scores)
                max_score = max(scores)
                print(f"üìä Score Statistics:")
                print(f"  ‚Ä¢ Average Score: {avg_score:.2f}")
                print(f"  ‚Ä¢ Min Score: {min_score:.2f}")
                print(f"  ‚Ä¢ Max Score: {max_score:.2f}")
                print()
            
            if prices:
                avg_price = sum(prices) / len(prices)
                min_price = min(prices)
                max_price = max(prices)
                print(f"üí∞ Price Statistics:")
                print(f"  ‚Ä¢ Average Price: ‚Çπ{avg_price:.2f}")
                print(f"  ‚Ä¢ Min Price: ‚Çπ{min_price:.2f}")
                print(f"  ‚Ä¢ Max Price: ‚Çπ{max_price:.2f}")
                print()
            
            # Recent recommendations
            print("üïí Recent Recommendations:")
            recent_data = []
            for rec in history[:10]:  # Show last 10
                recent_data.append([
                    rec.get('strategy', 'N/A'),
                    f"‚Çπ{rec.get('price_at_recommendation', 0):.2f}",
                    f"{rec.get('overall_score', 0):.1f}",
                    rec.get('recommendation_action', 'N/A'),
                    rec.get('generated_at', 'N/A')[:19] if rec.get('generated_at') else 'N/A'
                ])
            
            headers = ['Strategy', 'Price', 'Score', 'Action', 'Generated At']
            print(tabulate(recent_data, headers=headers, tablefmt='grid'))
            
        except Exception as e:
            print(f"‚ùå Error in symbol analysis: {e}")
    
    async def show_performance_summary(self, 
                                       top: int = 20,
                                       days: int = 7):
        """Show top performing recommendations summary."""
        
        try:
            print(f"\nüèÜ Top {top} Recommendations (Last {days} days)")
            print("=" * 70)
            
            # Get recent history
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            history = await self.storage.get_recommendation_history(
                start_date=start_date,
                end_date=end_date,
                limit=500  # Get more to find top performers
            )
            
            if not history:
                print("‚ùå No recommendations found for the specified period")
                return
            
            # Sort by score and take top N
            sorted_history = sorted(
                history, 
                key=lambda x: x.get('overall_score', 0), 
                reverse=True
            )[:top]
            
            # Display top recommendations
            table_data = []
            for i, rec in enumerate(sorted_history, 1):
                table_data.append([
                    i,
                    rec.get('symbol', 'N/A'),
                    rec.get('name', 'N/A')[:20],
                    rec.get('strategy', 'N/A'),
                    f"{rec.get('overall_score', 0):.1f}",
                    f"‚Çπ{rec.get('price_at_recommendation', 0):.2f}",
                    rec.get('recommendation_action', 'N/A'),
                    rec.get('generated_at', 'N/A')[:10] if rec.get('generated_at') else 'N/A'
                ])
            
            headers = [
                'Rank', 'Symbol', 'Company', 'Strategy', 'Score', 
                'Price', 'Action', 'Date'
            ]
            
            print(tabulate(table_data, headers=headers, tablefmt='grid'))
            
            # Summary statistics
            scores = [rec.get('overall_score', 0) for rec in sorted_history]
            avg_score = sum(scores) / len(scores) if scores else 0
            
            print(f"\nüìä Summary:")
            print(f"  ‚Ä¢ Average Score: {avg_score:.2f}")
            print(f"  ‚Ä¢ Score Range: {min(scores):.1f} - {max(scores):.1f}")
            print(f"  ‚Ä¢ Total Recommendations Analyzed: {len(history)}")
            
        except Exception as e:
            print(f"‚ùå Error showing performance summary: {e}")
    
    async def compare_strategies(self, 
                                 strategies: List[str],
                                 days: int = 30):
        """Compare performance across different strategies."""
        
        try:
            print(f"\n‚öñÔ∏è Strategy Comparison (Last {days} days)")
            print("=" * 70)
            
            comparison_data = {}
            
            for strategy in strategies:
                strategy_enum = None
                strategy_mapping = {
                    'shortterm': RecommendationStrategy.SHORTTERM,
                    'swing': RecommendationStrategy.SWING,
                    'longterm': RecommendationStrategy.LONGTERM,
                    'intraday': RecommendationStrategy.INTRADAY
                }
                strategy_enum = strategy_mapping.get(strategy.lower())
                
                if not strategy_enum:
                    print(f"‚ö†Ô∏è Unknown strategy: {strategy}")
                    continue
                
                # Get data for this strategy
                end_date = datetime.now()
                start_date = end_date - timedelta(days=days)
                
                history = await self.storage.get_recommendation_history(
                    strategy=strategy_enum,
                    start_date=start_date,
                    end_date=end_date,
                    limit=1000
                )
                
                if history:
                    scores = [rec.get('overall_score', 0) for rec in history]
                    prices = [rec.get('price_at_recommendation', 0) for rec in history if rec.get('price_at_recommendation', 0) > 0]
                    
                    comparison_data[strategy] = {
                        'total_recommendations': len(history),
                        'avg_score': sum(scores) / len(scores) if scores else 0,
                        'max_score': max(scores) if scores else 0,
                        'min_score': min(scores) if scores else 0,
                        'avg_price': sum(prices) / len(prices) if prices else 0,
                        'unique_symbols': len(set(rec.get('symbol', '') for rec in history))
                    }
                else:
                    comparison_data[strategy] = {
                        'total_recommendations': 0,
                        'avg_score': 0,
                        'max_score': 0,
                        'min_score': 0,
                        'avg_price': 0,
                        'unique_symbols': 0
                    }
            
            # Display comparison table
            table_data = []
            for strategy, data in comparison_data.items():
                table_data.append([
                    strategy.upper(),
                    data['total_recommendations'],
                    f"{data['avg_score']:.2f}",
                    f"{data['max_score']:.1f}",
                    f"‚Çπ{data['avg_price']:.2f}",
                    data['unique_symbols']
                ])
            
            headers = [
                'Strategy', 'Total Recs', 'Avg Score', 'Max Score', 'Avg Price', 'Symbols'
            ]
            
            print(tabulate(table_data, headers=headers, tablefmt='grid'))
            
            # Analysis insights
            print(f"\nüîç Analysis Insights:")
            if comparison_data:
                best_avg_score = max(comparison_data.items(), key=lambda x: x[1]['avg_score'])
                most_active = max(comparison_data.items(), key=lambda x: x[1]['total_recommendations'])
                most_diverse = max(comparison_data.items(), key=lambda x: x[1]['unique_symbols'])
                
                print(f"  ‚Ä¢ Best Average Score: {best_avg_score[0].upper()} ({best_avg_score[1]['avg_score']:.2f})")
                print(f"  ‚Ä¢ Most Active: {most_active[0].upper()} ({most_active[1]['total_recommendations']} recommendations)")
                print(f"  ‚Ä¢ Most Diverse: {most_diverse[0].upper()} ({most_diverse[1]['unique_symbols']} symbols)")
            
        except Exception as e:
            print(f"‚ùå Error comparing strategies: {e}")
    
    async def export_data(self, 
                          format: str = 'csv',
                          days: int = 7,
                          filename: Optional[str] = None):
        """Export recommendation data to CSV or JSON."""
        
        try:
            print(f"\nüíæ Exporting Recommendation Data")
            print("=" * 50)
            
            # Get data
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            history = await self.storage.get_recommendation_history(
                start_date=start_date,
                end_date=end_date,
                limit=10000  # Large limit for export
            )
            
            if not history:
                print("‚ùå No data to export")
                return
            
            # Generate filename if not provided
            if not filename:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"recommendation_history_{timestamp}.{format}"
            
            if format.lower() == 'csv':
                # Export to CSV
                with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                    if history:
                        fieldnames = history[0].keys()
                        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                        writer.writeheader()
                        for row in history:
                            # Convert datetime objects to strings for CSV
                            row_copy = row.copy()
                            for key, value in row_copy.items():
                                if isinstance(value, datetime):
                                    row_copy[key] = value.isoformat()
                            writer.writerow(row_copy)
                        
            elif format.lower() == 'json':
                # Export to JSON
                with open(filename, 'w', encoding='utf-8') as jsonfile:
                    # Convert datetime objects to strings for JSON
                    export_data = []
                    for rec in history:
                        rec_copy = rec.copy()
                        for key, value in rec_copy.items():
                            if isinstance(value, datetime):
                                rec_copy[key] = value.isoformat()
                        export_data.append(rec_copy)
                    
                    json.dump({
                        'export_metadata': {
                            'export_date': datetime.now().isoformat(),
                            'date_range': {
                                'start': start_date.isoformat(),
                                'end': end_date.isoformat()
                            },
                            'total_records': len(export_data)
                        },
                        'recommendations': export_data
                    }, jsonfile, indent=2, default=str)
            
            else:
                print(f"‚ùå Unsupported format: {format}")
                return
            
            print(f"‚úÖ Exported {len(history)} recommendations to {filename}")
            print(f"üìÖ Date Range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
            
        except Exception as e:
            print(f"‚ùå Error exporting data: {e}")
    
    async def live_monitoring(self, refresh_seconds: int = 30):
        """Live monitoring dashboard for new recommendations."""
        
        try:
            print(f"\nüì° Live Recommendation Monitoring")
            print(f"üîÑ Refreshing every {refresh_seconds} seconds (Press Ctrl+C to stop)")
            print("=" * 70)
            
            last_check = datetime.now() - timedelta(minutes=5)
            
            while True:
                try:
                    # Clear screen (works on most terminals)
                    print("\033[2J\033[H", end="")
                    
                    current_time = datetime.now()
                    print(f"üì° Live Monitoring - {current_time.strftime('%Y-%m-%d %H:%M:%S')}")
                    print("=" * 70)
                    
                    # Get recent recommendations
                    recent = await self.storage.get_recommendation_history(
                        start_date=last_check,
                        end_date=current_time,
                        limit=50
                    )
                    
                    if recent:
                        print(f"üÜï {len(recent)} new recommendations since {last_check.strftime('%H:%M:%S')}")
                        
                        # Show latest recommendations
                        table_data = []
                        for rec in recent[:10]:  # Show latest 10
                            table_data.append([
                                rec.get('symbol', 'N/A'),
                                rec.get('strategy', 'N/A'),
                                f"{rec.get('overall_score', 0):.1f}",
                                f"‚Çπ{rec.get('price_at_recommendation', 0):.2f}",
                                rec.get('recommendation_action', 'N/A'),
                                rec.get('generated_at', 'N/A')[:19] if rec.get('generated_at') else 'N/A'
                            ])
                        
                        headers = ['Symbol', 'Strategy', 'Score', 'Price', 'Action', 'Time']
                        print(tabulate(table_data, headers=headers, tablefmt='grid'))
                    else:
                        print("‚è≥ No new recommendations since last check")
                    
                    print(f"\nüîÑ Next refresh in {refresh_seconds} seconds...")
                    
                    # Update last check time
                    last_check = current_time
                    
                    # Wait for next refresh
                    await asyncio.sleep(refresh_seconds)
                    
                except KeyboardInterrupt:
                    print("\n\nüëã Monitoring stopped by user")
                    break
                    
        except Exception as e:
            print(f"‚ùå Error in live monitoring: {e}")

async def main():
    """Main function to handle command line arguments and execute commands."""
    
    parser = argparse.ArgumentParser(
        description="Recommendation History Analytics Viewer",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s history --days 7 --limit 50
  %(prog)s analytics --strategy shortterm --days 30
  %(prog)s symbols --symbol RELIANCE --days 30
  %(prog)s performance --top 20 --days 7
  %(prog)s compare --strategies shortterm,swing --days 30
  %(prog)s export --format csv --days 7 --filename recommendations.csv
  %(prog)s live --refresh 30
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # History command
    history_parser = subparsers.add_parser('history', help='View recommendation history')
    history_parser.add_argument('--symbol', help='Filter by symbol')
    history_parser.add_argument('--strategy', choices=['shortterm', 'swing', 'longterm', 'intraday'], help='Filter by strategy')
    history_parser.add_argument('--days', type=int, default=7, help='Number of days to look back (default: 7)')
    history_parser.add_argument('--limit', type=int, default=50, help='Maximum number of results (default: 50)')
    
    # Analytics command
    analytics_parser = subparsers.add_parser('analytics', help='Show batch analytics')
    analytics_parser.add_argument('--strategy', choices=['shortterm', 'swing', 'longterm', 'intraday'], help='Filter by strategy')
    analytics_parser.add_argument('--days', type=int, default=30, help='Number of days to analyze (default: 30)')
    
    # Symbol analysis command
    symbols_parser = subparsers.add_parser('symbols', help='Analyze specific symbol')
    symbols_parser.add_argument('--symbol', required=True, help='Symbol to analyze')
    symbols_parser.add_argument('--days', type=int, default=30, help='Number of days to analyze (default: 30)')
    
    # Performance command
    performance_parser = subparsers.add_parser('performance', help='Show top performing recommendations')
    performance_parser.add_argument('--top', type=int, default=20, help='Number of top recommendations (default: 20)')
    performance_parser.add_argument('--days', type=int, default=7, help='Number of days to analyze (default: 7)')
    
    # Compare command
    compare_parser = subparsers.add_parser('compare', help='Compare strategies')
    compare_parser.add_argument('--strategies', required=True, help='Comma-separated list of strategies to compare')
    compare_parser.add_argument('--days', type=int, default=30, help='Number of days to analyze (default: 30)')
    
    # Export command
    export_parser = subparsers.add_parser('export', help='Export data to file')
    export_parser.add_argument('--format', choices=['csv', 'json'], default='csv', help='Export format (default: csv)')
    export_parser.add_argument('--days', type=int, default=7, help='Number of days to export (default: 7)')
    export_parser.add_argument('--filename', help='Output filename (auto-generated if not specified)')
    
    # Live monitoring command
    live_parser = subparsers.add_parser('live', help='Live monitoring dashboard')
    live_parser.add_argument('--refresh', type=int, default=30, help='Refresh interval in seconds (default: 30)')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    # Initialize viewer
    viewer = RecommendationHistoryViewer()
    
    try:
        await viewer.initialize()
        
        # Execute commands
        if args.command == 'history':
            await viewer.show_recommendation_history(
                symbol=args.symbol,
                strategy=args.strategy,
                days=args.days,
                limit=args.limit
            )
        
        elif args.command == 'analytics':
            await viewer.show_batch_analytics(
                strategy=args.strategy,
                days=args.days
            )
        
        elif args.command == 'symbols':
            await viewer.show_symbol_analysis(
                symbol=args.symbol,
                days=args.days
            )
        
        elif args.command == 'performance':
            await viewer.show_performance_summary(
                top=args.top,
                days=args.days
            )
        
        elif args.command == 'compare':
            strategies = [s.strip() for s in args.strategies.split(',')]
            await viewer.compare_strategies(
                strategies=strategies,
                days=args.days
            )
        
        elif args.command == 'export':
            await viewer.export_data(
                format=args.format,
                days=args.days,
                filename=args.filename
            )
        
        elif args.command == 'live':
            await viewer.live_monitoring(
                refresh_seconds=args.refresh
            )
        
    except KeyboardInterrupt:
        print("\nüëã Operation cancelled by user")
    except Exception as e:
        print(f"‚ùå Error: {e}")
    finally:
        await viewer.close()

if __name__ == "__main__":
    asyncio.run(main()) 