---
description: Master project rules - deployment, ports, folder design, refactoring, integration tests
alwaysApply: true
---

# AlgoDiscovery Project Master Rules

## 1. Branch & Commit Policy

- **main**: NEVER commit directly. Direct changes on main are forbidden. main is pull-only for deploy to stage and prod.
- **All code changes**: Commit only on other branches (e.g. `develop`, `frontend_streamline_v1.1.1`, `feature/*`). Merge to main via PR only.
- **Issues found in staging**: Create a branch from main → fix → commit → merge. This is the only way to fix staging issues.
- **Flow**: Branch → develop/fix → commit → PR → merge to main → GCP pull main → deploy.

## 2. Deployment Policy (GIT-ONLY)

- **Deployment**: ONLY via Git. NO direct file transfer (no scp, rsync, ftp).
- **Prod**: `main` branch only. `./scripts/deploy-from-git.sh prod` on GCP instance. Port 80/443.
- **Stage**: `develop` branch only, local. `./scripts/deploy-stage-local.sh` — fetches and resets to **origin/develop**, then build + Docker on port 8080. For quick test on other branches (no Docker): `./scripts/run-quick-test.sh` (port 3002).
- **Dev**: Local, port 3000, `frontend/envs/env.dev`.

### STRICT: Push first, then deploy stage
- **Stage deploy script pulls from origin/develop.** It does not use your local uncommitted or unpushed commits.
- **Before running `deploy-stage-local.sh`:** commit all changes on `develop`, then **push to origin** (`git push origin develop`). If you do not push first, the script will reset to what is already on origin/develop and your latest local commits will not be deployed.
- **Order:** 1) Commit on develop. 2) Push to origin (develop). 3) Run `./scripts/deploy-stage-local.sh`. Never run the stage deploy script when you have unpushed commits on develop if you want those changes in the staged build.

### Deployment Checklist
- Before deploy: Run integration tests locally (`npm run test` in frontend).
- Before **stage** deploy: Push develop to origin first.
- Before **prod** deploy: Merge to main via PR; never deploy prod from unmerged branches.
- Env files: `frontend/envs/env.dev`, `env.stage`, `env.prod` (no envs outside `envs/`).

---

## 3. Port Reference (Update Master Rule When Changes Occur)

| Port | Service | Environment | Notes |
|------|---------|-------------|-------|
| 3000 | React dev server | Dev | `npm run start:dev` |
| 3001 | React dev server | Stage | `npm run start:stage` |
| 8080 | Served build | Stage | `npm run serve:stage` |
| 80 / 443 | Frontend (Nginx) | Prod | Docker serves here |
| 8001 | Longterm API, Chartink | Prod | Internal |
| 8002 | Swing API, Unified Strategy | Dev/Prod | REACT_APP_API_BASE_URL (dev) |
| 8010 | Recommendation API | Dev | |
| 8013 | Algorithm API, Zerodha | Dev/Prod | |
| 8018 | Stock Candidate Populator | Dev/Prod | |
| 8020 | Theme API | Dev/Prod | |
| 8030 | Strategies API | Dev/Prod | |
| 8079 | Kite Services, Kite Token | Dev/Prod | |
| 8081 | Chartink Auth | Dev | Local proxy target |
| 8082 | Seed API | Dev/Prod | |
| 8182 | Seed Service | Prod | External (algodiscovery.com) |
| 8183 | Recommendation/Proxy target | Dev | setupProxy target |

**Kill process by port**: Use `lsof -ti:<PORT> | xargs kill -9` — never kill by partial command that other processes use.

---

## 4. Folder Design & Structure (SUPER CLEAN – TARGET)

```
alg-discovery/
├── .cursor/rules/
├── docs/                    # Repo-level: deployment only
│   └── DEPLOYMENT.md
├── scripts/                 # Deploy only (no scattered .sh in frontend)
│   └── deploy-from-git.sh   # Canonical deploy for stage/prod
└── frontend/
    ├── docs/                # All frontend docs (README at root only)
    │   ├── README.md
    │   ├── integration/
    │   ├── architecture/
    │   ├── user-experience/
    │   └── configuration/
    ├── envs/                # env.dev, env.stage, env.prod, env.example
    ├── nginx.conf           # Single nginx config
    ├── Dockerfile           # Single Dockerfile (prod build)
    ├── docker-compose.yml   # Single compose file
    ├── src/
    │   ├── components/
    │   ├── config/
    │   ├── hooks/
    │   ├── pages/
    │   ├── services/
    │   └── types/
    └── public/
```

- **Docs**: All `.md` in `frontend/docs/`. Only README at docs root; content in subfolders.
- **Config**: Env, config modules. No hardcoding. No duplicates.
- **Services**: One concern per file. No duplicate logic.

---

## 5. Refactoring Rules

- Scan for similar logic before writing; refactor instead of duplicating.
- Prefer small, focused modules with clear exports.
- Use data models (types/interfaces) for API payloads and state.
- Use minimal code with maximum reusability.
- Log to files for debugging and audit; follow project logging patterns.

---

## 6. Integration Test & Verification

- Run `npm run test` before commit when touching frontend.
- Quick verification: `npm run build:prod` (uses `envs/env.prod`) must succeed.
- Health checks: `curl -f http://localhost/health` (prod), `curl http://localhost:3000` (dev).
- After deploy: verify `/health` and main app route load.

---

## 7. STATE-OF-THE-ART CODE RULES (STRICT)

### Principles
- **SOLID**: Single responsibility, Open/closed, Liskov substitution, Interface segregation, Dependency inversion.
- **DRY/KISS/YAGNI**: Don't Repeat Yourself. Keep It Simple. You Aren't Gonna Need It.
- **Explicit over implicit**: Fail fast, explicit errors, clear contracts. No silent failures.
- **Immutable by default**: Prefer `const`, avoid mutating state. Use pure functions where possible.
- **Readability over cleverness**: Code is read 10× more than written. No magic, no abbreviations.

### TypeScript / React
- **Strict types**: No `any`. Use `unknown` or proper types. Explicit return types on public functions.
- **Data models**: All API payloads, state, props use interfaces/types. One source in `types/` or colocated.
- **Functional components + hooks**: No class components. Extract logic to custom hooks.
- **Composition over inheritance**: Prefer composition, small components. No deep hierarchies.
- **Controlled inputs**: Form state is explicit. No uncontrolled unless justified.
- **Error boundaries**: Wrap route-level or critical trees. Log to file, not console only.
- **Keys**: Stable, unique keys on lists. No array index as key when list can change.
- **Memoization**: `useMemo`/`useCallback` only when profiling shows need. Avoid premature optimization.

### Async & API
- **Error handling**: Every `async`/`fetch` in try/catch. Surface errors to user or log. Never swallow.
- **Timeouts**: Set timeout on external calls. Use config, not magic numbers.
- **Retries**: Use configurable retry for idempotent operations only.
- **Abort**: Support `AbortSignal` for cancellable requests where applicable.

### Security & Config
- **No secrets in code**: API keys, tokens only in env. Never commit.
- **Validate inputs**: Sanitize/validate user input and API responses at boundaries.
- **Config over code**: All tunables (URLs, timeouts, feature flags) from config/env.

### Logging & Observability
- **Log to file**: Production paths log to file. Use structured logs (JSON) when possible.
- **No console in prod**: `console.log` only for dev. Use logger with levels.
- **Correlation**: Include request/transaction IDs in logs for tracing.

### Code anti-patterns (FORBIDDEN)
- `any`, untyped catches, silent `catch (e) {}`
- Hardcoded URLs, ports, magic numbers
- Copy-paste; extract to shared fn/module
- Deep prop drilling; use context or state management
- Mutable shared state; prefer local state or well-defined stores
- Untested critical paths; add tests for business logic

## 8. Clean Code Rules (STRICT)

- **Docs**: All `.md` in `frontend/docs/`. No loose docs in frontend root.
- **No irrelevant code**: Remove unused components, duplicate services, one-off scripts. If it's not referenced, delete it.
- **No duplicate files**: One source of truth per config (e.g. one openai.json, one env pattern).
- **Before adding**: Scan for existing equivalent; reuse or refactor. Do not add similar new files.

## 9. FORBIDDEN (STRICTLY enforce)

- **Env**: ONLY `frontend/envs/env.dev`, `env.stage`, `env.prod`, `env.example`. No `env.*` at frontend root.
- **Nginx**: ONLY `frontend/nginx.conf`. No `nginx-*.conf`.
- **Config**: No duplicate config files. No hardcoded values.
- **Redundant logic**: No duplicate services. No copy-paste; refactor.
- **Scripts**: No redundant npm scripts. One canonical script per action.

## 10. DOCKER (STRICT – ONE of each)

- **Dockerfile**: ONE `frontend/Dockerfile`. No `Dockerfile.*` variants.
- **docker-compose**: ONE `frontend/docker-compose.yml`. No `docker-compose-*.yml` (port80, 8080, domain, full-stack).
- **Build arg**: Use `BUILD_ENV=prod|stage` in single Dockerfile. No separate Dockerfiles per port/domain.
- **FORBIDDEN**: `Dockerfile.*` (except Dockerfile), `docker-compose-*.yml` variants.

## 11. DEPLOY SCRIPTS (STRICT – MINIMAL)

- **deploy-from-git.sh**: Main branch only. `./scripts/deploy-from-git.sh [stage|prod]`. stage = main local 8080, prod = GCP.
- **deploy-stage-local.sh**: Stage from **develop** only (local, full Docker, 8080). Fetches and resets to **origin/develop** — **push to origin first** or your latest commits will not be deployed.
- **run-quick-test.sh**: Quick test on current branch, no Docker, port 3002.
- **Frontend**: ONE optional `frontend/deploy.sh` for local Docker run.

### STRICT: Stage deploy = push first
- `deploy-stage-local.sh` runs `git fetch origin` and `git reset --hard origin/develop`. It does **not** deploy local-only commits. **Always push develop to origin before running the script.**
- **FORBIDDEN**: Running stage deploy with unpushed commits on develop when those commits must be in the staged build.

## 12. OVERALL PRINCIPLE

**Super clean = One source of truth per concern.** No variants, no duplicates, no legacy files. Before adding any file: Does an equivalent exist? If yes, extend it. If no, add minimally. Strictly follow this structure; deviations are FORBIDDEN.
